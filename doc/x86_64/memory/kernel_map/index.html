<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `kernel_map` mod in crate `x86_64`."><meta name="keywords" content="rust, rustlang, rust-lang, kernel_map"><title>x86_64::memory::kernel_map - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../x86_64/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a><p class='location'>Module kernel_map</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'><a href='../../index.html'>x86_64</a>::<wbr><a href='../index.html'>memory</a></p><script>window.sidebarCurrent = {name: 'kernel_map', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../../src/x86_64/memory/kernel_map.rs.html#1-73' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../../index.html'>x86_64</a>::<wbr><a href='../index.html'>memory</a>::<wbr><a class="mod" href=''>kernel_map</a></span></h1><div class='docblock'><p>These constants centralize the layout of the virtual address space on x86_64. The 511th P4
entry (covering addresses <code>0xffff_ff80_0000_0000</code> through to <code>0xffff_ffff_ffff_ffff</code>) is always
mapped to the kernel P3 (which includes the physical memory mappings). The rest of the address
space (addresses <code>0x0000_0000_0000_0000</code> through to <code>0xffff_ff7f_ffff_ffff</code>) are free for
userspace to use.</p>
<p>This gives us 512 GiB of kernel space. The kernel itself is build with the <code>kernel</code> mc-model
and so must run in the -2 GiB of the address space (this is the top two entries of the P3).
The remaining 510 GiB are used for mapping the entirity of physical memory into the virtual
address space, and for each task's kernel stack.</p>
<p>128 GiB are reserved for kernel stacks for tasks, with a maximum of a total of 65536 tasks
1024 address spaces. This lies directly below <code>KERNEL_BASE</code>.</p>
<p>This leaves 382 GiB for the physical memory map, which should be more than enough for any
reasonable system we can imagine running on.</p>
</div><h2 id='constants' class='section-header'><a href="#constants">Constants</a></h2>
<table><tr class='module-item'><td><a class="constant" href="constant.ADDRESS_SPACE_STACK_SLOT_SIZE.html" title='x86_64::memory::kernel_map::ADDRESS_SPACE_STACK_SLOT_SIZE constant'>ADDRESS_SPACE_STACK_SLOT_SIZE</a></td><td class='docblock-short'><p>The size of a slot of stacks that is allocated for a single address space to use.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.BOOT_INFO.html" title='x86_64::memory::kernel_map::BOOT_INFO constant'>BOOT_INFO</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.BOOT_INFO_NUM_PAGES.html" title='x86_64::memory::kernel_map::BOOT_INFO_NUM_PAGES constant'>BOOT_INFO_NUM_PAGES</a></td><td class='docblock-short'><p>This is the number of 4KiB pages we need to allocate for the boot info. We also need to respect this
in the virtual address space allocation.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.HEAP_END.html" title='x86_64::memory::kernel_map::HEAP_END constant'>HEAP_END</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.HEAP_START.html" title='x86_64::memory::kernel_map::HEAP_START constant'>HEAP_START</a></td><td class='docblock-short'><p>The start of the heap. The heap is 200 KiB.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.KERNEL_ADDRESS_SPACE_START.html" title='x86_64::memory::kernel_map::KERNEL_ADDRESS_SPACE_START constant'>KERNEL_ADDRESS_SPACE_START</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.KERNEL_BASE.html" title='x86_64::memory::kernel_map::KERNEL_BASE constant'>KERNEL_BASE</a></td><td class='docblock-short'><p>This is the base of the kernel address space. It starts at -2GB. We don't know how much memory
the kernel image will take up when loaded into memory, so we leave quite a lot of space until
the next statically mapped thing.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.KERNEL_P4_ENTRY.html" title='x86_64::memory::kernel_map::KERNEL_P4_ENTRY constant'>KERNEL_P4_ENTRY</a></td><td class='docblock-short'><p>The kernel is mapped into the 511th entry of the P4.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.KERNEL_STACKS_BASE.html" title='x86_64::memory::kernel_map::KERNEL_STACKS_BASE constant'>KERNEL_STACKS_BASE</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.LOCAL_APIC_CONFIG.html" title='x86_64::memory::kernel_map::LOCAL_APIC_CONFIG constant'>LOCAL_APIC_CONFIG</a></td><td class='docblock-short'><p>While we could access the local APIC from the physical mapping, it's easier to just map it to a
fixed virtual address, so we can always access its config space. This allows us to use
<code>LocalApic</code> as a singleton, so we can easily access it from interrupt handlers.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.MAX_ADDRESS_SPACES.html" title='x86_64::memory::kernel_map::MAX_ADDRESS_SPACES constant'>MAX_ADDRESS_SPACES</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.MAX_TASKS_PER_ADDRESS_SPACE.html" title='x86_64::memory::kernel_map::MAX_TASKS_PER_ADDRESS_SPACE constant'>MAX_TASKS_PER_ADDRESS_SPACE</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="constant" href="constant.PHYSICAL_MAPPING_BASE.html" title='x86_64::memory::kernel_map::PHYSICAL_MAPPING_BASE constant'>PHYSICAL_MAPPING_BASE</a></td><td class='docblock-short'><p>The base virtual address of the physical memory mapping. This is equal to
<code>KERNEL_ADDRESS_SPACE_START</code> because we map the physical memory at the start of the kernel's P4
entry.</p>
</td></tr><tr class='module-item'><td><a class="constant" href="constant.STACK_SLOT_SIZE.html" title='x86_64::memory::kernel_map::STACK_SLOT_SIZE constant'>STACK_SLOT_SIZE</a></td><td class='docblock-short'><p>The size of a single kernel stack.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.kernel_stack_area_base.html" title='x86_64::memory::kernel_map::kernel_stack_area_base fn'>kernel_stack_area_base</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.physical_to_virtual.html" title='x86_64::memory::kernel_map::physical_to_virtual fn'>physical_to_virtual</a></td><td class='docblock-short'><p>Access a given <code>PhysicalAddress</code> using the physical memory mapping in the kernel address space.
Only works within the kernel - cannot be used by the bootloader, and the addresses can't be
given to userspace.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../";window.currentCrate = "x86_64";</script><script src="../../../aliases.js"></script><script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>