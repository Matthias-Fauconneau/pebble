initSidebarItems({"fn":[["kmain","This is the entry point for the kernel on x86_64. It is called from the UEFI bootloader and initialises the system, then passes control into the common part of the kernel."],["panic",""]],"macro":[["kernel_object_table",""],["restore_regs","Restore the saved scratch registers."],["save_regs","Macro to save the scratch registers. In System-V, `rbx`, `rbp`, `r12`, `r13`, `r14`, and `r15` must be restored by the callee, so Rust automatically generates code to restore them, but for the rest we have to manually preserve them. Use `restore_regs` to restore the scratch registers before returning from the handler."],["set_handler",""],["set_handler_with_error_code",""],["wrap_handler",""],["wrap_handler_with_error_code",""]],"mod":[["arch",""],["heap_allocator",""],["mailbox",""],["object",""],["per_cpu",""],["scheduler",""],["syscall",""],["x86_64","This module defines the kernel entry-point on x86_64."]],"static":[["ALLOCATOR",""],["COMMON","We need to make various bits of data accessible on a system-wide level (all the CPUs access the same data), including from system call and interrupt handlers. I haven't discovered a particularly elegant way of doing that in Rust yet, but this isn't totally awful."]],"struct":[["Common","This is a collection of stuff we need to access from around the kernel, shared between all CPUs. This has the potential to end up as a bit of a \"God struct\", so we need to be careful."]]});