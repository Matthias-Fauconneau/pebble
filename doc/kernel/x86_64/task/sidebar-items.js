initSidebarItems({"enum":[["TaskCreationError",""]],"fn":[["context_switch","Perform a context-switch between the currently running task, `old`, and a new task, `new`. This function is fairly fragile as it may not always return (in the case of the new task never having been run before, in which case this returns into the trampoline instead of back up the kernel callstack), and so we have to be very careful to drop any locks we hold before \"returning\""],["decode_capabilities","Decode a capability stream (as found in a task's image) into a set of capabilities as they're represented in the kernel. For the format that's being decoded here, refer to the `(3.1) Userspace/Capabilities` section of the Book."],["do_context_switch","Do the actual context switch: save the context of the old task on its kernel stack, switch to the new task's kernel stack, restore its context and return. The only non-trivial part of this is the returning - for tasks that have run before, we simply work our way back up the kernel callstack and return to userspace from the syscall handler. However, for tasks that have never been run before, the stack frames leading back up to the handler aren't there, and so we manually insert a return to a kernel-space usermode trampoline that enters userspace for the first time in the initial stack frame, which is what the context switch returns to."],["drop_to_usermode","Drop into usermode into the given task. This permanently migrates from the kernel's initial stack (the one reserved in `.bss` and used during kernel initialization)."],["task_entry_trampoline",""]],"struct":[["ContextSwitchFrame","This is the layout of the stack that we expect to be present when we switch to a task. It is created both in preparation for initial task entry, and when we're switching away from a task. We use the C ABI here because we access this structure from assembly."],["Task","This is the representation of a task on x86_64. It's basically just keeps information about the current instruction pointer and the stack, as all other registers are preserved on the task stack when it's suspended."]]});