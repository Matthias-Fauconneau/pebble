<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `aml` crate."><meta name="keywords" content="rust, rustlang, rust-lang, aml"><title>aml - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../aml/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate aml</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all aml's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'aml', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/aml/lib.rs.html#1-248' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>aml</a></span></h1><div class='docblock'><p><code>aml</code> is a pure-Rust AML (ACPI Machine Language) parser, used for parsing the DSDT and
SSDT tables from ACPI. This crate can be used by kernels to gather information about the
hardware, and invoke control methods (this is not yet supported) to query and change the state
of devices in a hardware-independent way.</p>
<h3 id="using-the-library" class="section-header"><a href="#using-the-library">Using the library</a></h3>
<p>To use the library, you will mostly interact with the <code>AmlContext</code> type. You should create an
instance of this type using <code>AmlContext::new()</code>, and then pass it tables containing AML
(probably from the <code>acpi</code> crate), which you've mapped into the virtual address space. This will
parse the table, populating the namespace with objects encoded by the AML. After this, you may
unmap the memory the table was mapped into - all the information needed will be extracted and
allocated on the heap.</p>
<p>You can then access specific objects by name like so: e.g.</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">let</span> <span class="ident">my_aml_value</span> <span class="op">=</span> <span class="ident">aml_context</span>.<span class="ident">lookup</span>(<span class="kw-2">&amp;</span><span class="ident">AmlName</span>::<span class="ident">from_str</span>(<span class="string">&quot;\\_SB.PCI0.S08._ADR&quot;</span>).<span class="ident">unwrap</span>());</pre></div>
<h3 id="about-the-parser" class="section-header"><a href="#about-the-parser">About the parser</a></h3>
<p>The parser is written using a set of custom parser combinators - the code can be confusing on
first reading, but provides an extensible and type-safe way to write parsers. For an easy
introduction to parser combinators and the foundations used for this library, I suggest reading
<a href="https://bodil.lol/parser-combinators/">Bodil's fantastic blog post</a>.</p>
<p>The actual combinators can be found in <code>parser.rs</code>. Various tricks are used to provide a nice
API and work around limitations in the type system, such as the concrete types like
<code>MapWithContext</code>, and the <code>make_parser_concrete</code> hack macro.</p>
<p>The actual parsers are then grouped into categories based loosely on the AML grammar sections in
the ACPI spec. Most are written in terms of combinators, but some have to be written in a more
imperitive style, either because they're clearer, or because we haven't yet found good
combinator patterns to express the parse.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::value::<a class="enum" href="../aml/value/enum.AmlValue.html" title="enum aml::value::AmlValue">AmlValue</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="value/index.html" title='aml::value mod'>value</a></td><td class='docblock-short'></td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.choice.html" title='aml::choice macro'>choice</a></td><td class='docblock-short'><p>Takes a number of parsers, and tries to apply each one to the input in order. Returns the
result of the first one that succeeds, or fails if all of them fail.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.make_parser_concrete.html" title='aml::make_parser_concrete macro'>make_parser_concrete</a></td><td class='docblock-short'><p>This encapsulates an unfortunate hack we sometimes need to use, where the type checker gets
caught in an infinite loop of parser types. This occurs when an object can indirectly contain
itself, and so the parser type will contain its own type. This works by breaking the cycle of
<code>impl Parser</code> chains that build up, by effectively creating a &quot;concrete&quot; closure type.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.try_with_context.html" title='aml::try_with_context macro'>try_with_context</a></td><td class='docblock-short'><p>Helper macro for use within <code>map_with_context</code> as an alternative to &quot;trying&quot; an expression.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.AmlContext.html" title='aml::AmlContext struct'>AmlContext</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.AmlHandle.html" title='aml::AmlHandle struct'>AmlHandle</a></td><td class='docblock-short'><p>A handle is used to refer to an AML value without actually borrowing it until you need to
access it (this makes borrowing situation much easier as you only have to consider who's
borrowing the namespace). They can also be cached to avoid expensive namespace lookups.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.AmlName.html" title='aml::AmlName struct'>AmlName</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.Namespace.html" title='aml::Namespace struct'>Namespace</a></td><td class='docblock-short'></td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.AmlError.html" title='aml::AmlError enum'>AmlError</a></td><td class='docblock-short'></td></tr></table><h2 id='constants' class='section-header'><a href="#constants">Constants</a></h2>
<table><tr class='module-item'><td><a class="constant" href="constant.AML_INTERPRETER_REVISION.html" title='aml::AML_INTERPRETER_REVISION constant'>AML_INTERPRETER_REVISION</a></td><td class='docblock-short'><p>AML has a <code>RevisionOp</code> operator that returns the &quot;AML interpreter revision&quot;. It's not clear
what this is actually used for, but this is ours.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "aml";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>