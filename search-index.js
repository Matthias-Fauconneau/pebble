var N = null;var searchIndex = {};
searchIndex["bit_field"]={"doc":"Provides the abstraction of a bit field, which allows for…","items":[[8,"BitField","bit_field","A generic trait which provides methods for extracting and…",N,N],[10,"bit_length","","Returns the length, eg number of bits, in this bit field.",0,[[],["usize"]]],[10,"get_bit","","Obtains the bit at the index `bit`; note that index 0 is…",0,[[["self"],["usize"]],["bool"]]],[10,"get_bits","","Obtains the range of bits specified by `range`; note that…",0,[[["self"],["range",["usize"]]],["self"]]],[10,"set_bit","","Sets the bit at the index `bit` to the value `value`…",0,[[["self"],["usize"],["bool"]],["self"]]],[10,"set_bits","","Sets the range of bits defined by the range `range` to the…",0,[[["self"],["range",["usize"]],["self"]],["self"]]],[8,"BitArray","","",N,N],[10,"bit_length","","Returns the length, eg number of bits, in this bit array.",1,[[["self"]],["usize"]]],[10,"get_bit","","Obtains the bit at the index `bit`; note that index 0 is…",1,[[["self"],["usize"]],["bool"]]],[10,"get_bits","","Obtains the range of bits specified by `range`; note that…",1,[[["self"],["range",["usize"]]],["t"]]],[10,"set_bit","","Sets the bit at the index `bit` to the value `value`…",1,[[["self"],["usize"],["bool"]]]],[10,"set_bits","","Sets the range of bits defined by the range `range` to the…",1,[[["self"],["range",["usize"]],["t"]]]]],"paths":[[8,"BitField"],[8,"BitArray"]]};
searchIndex["bitflags"]={"doc":"A typesafe bitmask flag generator useful for sets of…","items":[[14,"bitflags","bitflags","The macro used to generate the flag structure.",N,N]],"paths":[]};
searchIndex["cfg_if"]={"doc":"A macro for defining `#[cfg]` if-else statements.","items":[[14,"cfg_if","cfg_if","",N,N]],"paths":[]};
searchIndex["kernel"]={"doc":"","items":[[5,"kmain","kernel","This is the entry point for the kernel on x86_64. It is…",N,N],[5,"panic","","",N,N],[0,"x86_64","","This module defines the kernel entry-point on x86_64.",N,N],[5,"kmain","kernel::x86_64","This is the entry point for the kernel on x86_64. It is…",N,N],[0,"logger","","",N,N],[3,"KernelLogger","kernel::x86_64::logger","This handles calls to the log macros throughout the…",N,N],[7,"COM1","","The COM1 serial port, accessed through the UART 16550…",N,N],[0,"memory","kernel::x86_64","This module contains the physical memory manager Pebble…",N,N],[3,"MemoryController","kernel::x86_64::memory","",N,N],[12,"buddy_allocator","","",0,N],[3,"LockedMemoryController","","",N,N],[12,"0","","",1,N],[0,"buddy_allocator","","One of the allocators we use to manage physical memory is…",N,N],[3,"BuddyAllocator","kernel::x86_64::memory::buddy_allocator","",N,N],[12,"bins","","The bins of free blocks, where bin `i` contains blocks of…",2,N],[11,"new","","Create a new `BuddyAllocator`, with a maximum block size…",2,[[["usize"]],["buddyallocator"]]],[11,"add_range","","Add a range of `Frame`s to this allocator, marking them…",2,[[["self"],["range",["frame"]]]]],[11,"allocate_n","","Allocate (at least) `n` contiguous frames from this…",2,[[["self"],["usize"]],["option",["frame"]]]],[11,"free_n","","Free the given block (starting at `start` and of size `n`…",2,[[["self"],["frame"],["usize"]]]],[11,"allocate_block","","Tries to allocate a block of the given order. If no blocks…",2,[[["self"],["usize"]],["option",["frame"]]]],[11,"buddy_of","","Finds the starting frame of the block that is the buddy of…",2,[[["frame"],["usize"]],["frame"]]],[11,"max_order","","Get the order of the largest block this allocator can track.",2,[[["self"]],["usize"]]],[17,"BUDDY_ALLOCATOR_MAX_ORDER","kernel::x86_64::memory","",N,N],[11,"new","","",0,[[["bootinfo"]],["memorycontroller"]]],[11,"new","","",1,[[["bootinfo"]],["lockedmemorycontroller"]]],[0,"heap_allocator","kernel","",N,N],[3,"HoleAllocator","kernel::heap_allocator","",N,N],[12,"heap_bottom","","",3,N],[12,"heap_size","","",3,N],[12,"holes","","",3,N],[3,"LockedHoleAllocator","","",N,N],[12,"0","","",4,N],[3,"HoleInfo","","",N,N],[12,"addr","","",5,N],[12,"size","","",5,N],[3,"Hole","","",N,N],[12,"size","","",6,N],[12,"next","","",6,N],[3,"HoleList","","",N,N],[12,"first","","",7,N],[3,"Allocation","","",N,N],[12,"info","","",8,N],[12,"front_padding","","",8,N],[12,"back_padding","","",8,N],[5,"split_hole","","Split the given hole into…",N,[[["holeinfo"],["layout"]],["option",["allocation"]]]],[5,"allocate_first_fit","","",N,[[["hole"],["layout"]],["result",["allocation","allocerr"]]]],[5,"free","","Walk the list, starting at `hole` and free the allocation…",N,[[["hole"],["virtualaddress"],["usize"]]]],[5,"align_down","","Get the greatest x with the given alignment such that x <=…",N,[[["usize"],["usize"]],["usize"]]],[5,"align_up","","Get the smallest x with the given alignment such that x >=…",N,[[["usize"],["usize"]],["usize"]]],[5,"handle_alloc_error","","",N,N],[11,"new_uninitialized","","Create a new, uninitialized `HoleAllocator`. Before heap…",3,[[],["holeallocator"]]],[11,"init","","Initialise the `HoleAllocator`. This should only be called…",3,[[["self"],["virtualaddress"],["virtualaddress"]]]],[11,"new_uninitialized","","",4,[[],["lockedholeallocator"]]],[11,"info","","",6,[[["self"]],["holeinfo"]]],[11,"new","","Create a new `HoleList` that contains the given hole.…",7,[[["virtualaddress"],["usize"]],["holelist"]]],[11,"allocate_first_fit","","Search for a big enough hole for the given `Layout` with…",7,[[["self"],["layout"]],["result",["allocerr"]]]],[11,"free","","Free an allocation defined by `ptr` and `layout`. Unsafe…",7,N],[11,"get_min_size","","",7,[[],["usize"]]],[0,"util","kernel","",N,N],[0,"binary_pretty_print","kernel::util","",N,N],[3,"BinaryPrettyPrint","kernel::util::binary_pretty_print","Values can be wrapped in this type when they're printed to…",N,N],[12,"0","","",9,N],[0,"math","kernel::util","",N,N],[5,"flooring_log2","kernel::util::math","Fast integer `log2` that floors to the lower power-of-2 if…",N,[[["u64"]],["u64"]]],[5,"ceiling_log2","","",N,[[["u64"]],["u64"]]],[0,"__rg_allocator_abi","kernel","",N,N],[5,"__rg_alloc","kernel::__rg_allocator_abi","",N,N],[5,"__rg_dealloc","","",N,N],[5,"__rg_realloc","","",N,N],[5,"__rg_alloc_zeroed","","",N,N],[7,"ALLOCATOR","kernel","",N,N],[14,"assert_first_call","","This macro should be called at the beginning of functions…",N,N],[11,"from","kernel::x86_64::logger","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","kernel::x86_64::memory","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","kernel::x86_64::memory::buddy_allocator","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","kernel::heap_allocator","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","kernel::util::binary_pretty_print","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","kernel::heap_allocator","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","kernel::util::binary_pretty_print","",9,[[["self"],["formatter"]],["result"]]],[11,"deref","kernel::heap_allocator","",4,[[["self"]],["mutex"]]],[11,"clone","","",5,[[["self"]],["holeinfo"]]],[11,"clone","","",8,[[["self"]],["allocation"]]],[11,"alloc","","",4,N],[11,"dealloc","","",4,N],[11,"allocate_n","kernel::x86_64::memory","",1,[[["self"],["usize"]],["range",["frame"]]]],[11,"free_n","","",1,[[["self"],["frame"],["usize"]]]],[11,"enabled","kernel::x86_64::logger","",10,[[["self"],["metadata"]],["bool"]]],[11,"log","","",10,[[["self"],["record"]]]],[11,"flush","","",10,[[["self"]]]]],"paths":[[3,"MemoryController"],[3,"LockedMemoryController"],[3,"BuddyAllocator"],[3,"HoleAllocator"],[3,"LockedHoleAllocator"],[3,"HoleInfo"],[3,"Hole"],[3,"HoleList"],[3,"Allocation"],[3,"BinaryPrettyPrint"],[3,"KernelLogger"]]};
searchIndex["log"]={"doc":"A lightweight logging facade.","items":[[3,"Record","log","The \"payload\" of a log message.",N,N],[3,"RecordBuilder","","Builder for `Record`.",N,N],[3,"Metadata","","Metadata about a log message.",N,N],[3,"MetadataBuilder","","Builder for `Metadata`.",N,N],[3,"SetLoggerError","","The type returned by [`set_logger`] if [`set_logger`] has…",N,N],[3,"ParseLevelError","","The type returned by [`from_str`] when the string doesn't…",N,N],[4,"Level","","An enum representing the available verbosity levels of the…",N,N],[13,"Error","","The \"error\" level.",0,N],[13,"Warn","","The \"warn\" level.",0,N],[13,"Info","","The \"info\" level.",0,N],[13,"Debug","","The \"debug\" level.",0,N],[13,"Trace","","The \"trace\" level.",0,N],[4,"LevelFilter","","An enum representing the available verbosity level filters…",N,N],[13,"Off","","A level lower than all log levels.",1,N],[13,"Error","","Corresponds to the `Error` log level.",1,N],[13,"Warn","","Corresponds to the `Warn` log level.",1,N],[13,"Info","","Corresponds to the `Info` log level.",1,N],[13,"Debug","","Corresponds to the `Debug` log level.",1,N],[13,"Trace","","Corresponds to the `Trace` log level.",1,N],[5,"set_max_level","","Sets the global maximum log level.",N,[[["levelfilter"]]]],[5,"max_level","","Returns the current maximum log level.",N,[[],["levelfilter"]]],[5,"set_logger","","Sets the global logger to a `&'static Log`.",N,[[["log"]],["result",["setloggererror"]]]],[5,"logger","","Returns a reference to the logger.",N,[[],["log"]]],[17,"STATIC_MAX_LEVEL","","The statically resolved maximum log level.",N,N],[8,"Log","","A trait encapsulating the operations required of a logger.",N,N],[10,"enabled","","Determines if a log message with the specified metadata…",2,[[["self"],["metadata"]],["bool"]]],[10,"log","","Logs the `Record`.",2,[[["self"],["record"]]]],[10,"flush","","Flushes any buffered records.",2,[[["self"]]]],[11,"max","","Returns the most verbose logging level.",0,[[],["level"]]],[11,"to_level_filter","","Converts the `Level` to the equivalent `LevelFilter`.",0,[[["self"]],["levelfilter"]]],[11,"max","","Returns the most verbose logging level filter.",1,[[],["levelfilter"]]],[11,"to_level","","Converts `self` to the equivalent `Level`.",1,[[["self"]],["option",["level"]]]],[11,"builder","","Returns a new builder.",3,[[],["recordbuilder"]]],[11,"args","","The message body.",3,[[["self"]],["arguments"]]],[11,"metadata","","Metadata about the log directive.",3,[[["self"]],["metadata"]]],[11,"level","","The verbosity level of the message.",3,[[["self"]],["level"]]],[11,"target","","The name of the target of the directive.",3,[[["self"]],["str"]]],[11,"module_path","","The module path of the message.",3,[[["self"]],["option",["str"]]]],[11,"file","","The source file containing the message.",3,[[["self"]],["option",["str"]]]],[11,"line","","The line containing the message.",3,[[["self"]],["option",["u32"]]]],[11,"new","","Construct new `RecordBuilder`.",4,[[],["recordbuilder"]]],[11,"args","","Set `args`.",4,[[["self"],["arguments"]],["recordbuilder"]]],[11,"metadata","","Set `metadata`. Construct a `Metadata` object with…",4,[[["self"],["metadata"]],["recordbuilder"]]],[11,"level","","Set `Metadata::level`.",4,[[["self"],["level"]],["recordbuilder"]]],[11,"target","","Set `Metadata::target`",4,[[["self"],["str"]],["recordbuilder"]]],[11,"module_path","","Set `module_path`",4,[[["self"],["option",["str"]]],["recordbuilder"]]],[11,"file","","Set `file`",4,[[["self"],["option",["str"]]],["recordbuilder"]]],[11,"line","","Set `line`",4,[[["self"],["option",["u32"]]],["recordbuilder"]]],[11,"build","","Invoke the builder and return a `Record`",4,[[["self"]],["record"]]],[11,"builder","","Returns a new builder.",5,[[],["metadatabuilder"]]],[11,"level","","The verbosity level of the message.",5,[[["self"]],["level"]]],[11,"target","","The name of the target of the directive.",5,[[["self"]],["str"]]],[11,"new","","Construct a new `MetadataBuilder`.",6,[[],["metadatabuilder"]]],[11,"level","","Setter for `level`.",6,[[["self"],["level"]],["metadatabuilder"]]],[11,"target","","Setter for `target`.",6,[[["self"],["str"]],["metadatabuilder"]]],[11,"build","","Returns a `Metadata` object.",6,[[["self"]],["metadata"]]],[14,"log","","The standard logging macro.",N,N],[14,"error","","Logs a message at the error level.",N,N],[14,"warn","","Logs a message at the warn level.",N,N],[14,"info","","Logs a message at the info level.",N,N],[14,"debug","","Logs a message at the debug level.",N,N],[14,"trace","","Logs a message at the trace level.",N,N],[14,"log_enabled","","Determines if a message logged at the specified level in…",N,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["level"]],["bool"]]],[11,"eq","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"eq","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"eq","","",1,[[["self"],["level"]],["bool"]]],[11,"eq","","",5,[[["self"],["metadata"]],["bool"]]],[11,"ne","","",5,[[["self"],["metadata"]],["bool"]]],[11,"eq","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"ne","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"eq","","",8,[[["self"],["parselevelerror"]],["bool"]]],[11,"ne","","",8,[[["self"],["parselevelerror"]],["bool"]]],[11,"cmp","","",0,[[["self"],["level"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["levelfilter"]],["ordering"]]],[11,"cmp","","",5,[[["self"],["metadata"]],["ordering"]]],[11,"cmp","","",6,[[["self"],["metadatabuilder"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"],["level"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["level"]],["bool"]]],[11,"le","","",0,[[["self"],["level"]],["bool"]]],[11,"gt","","",0,[[["self"],["level"]],["bool"]]],[11,"ge","","",0,[[["self"],["level"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["levelfilter"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"le","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"gt","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"ge","","",0,[[["self"],["levelfilter"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["levelfilter"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"le","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"gt","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"ge","","",1,[[["self"],["levelfilter"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["level"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["level"]],["bool"]]],[11,"le","","",1,[[["self"],["level"]],["bool"]]],[11,"gt","","",1,[[["self"],["level"]],["bool"]]],[11,"ge","","",1,[[["self"],["level"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["metadata"]],["option",["ordering"]]]],[11,"lt","","",5,[[["self"],["metadata"]],["bool"]]],[11,"le","","",5,[[["self"],["metadata"]],["bool"]]],[11,"gt","","",5,[[["self"],["metadata"]],["bool"]]],[11,"ge","","",5,[[["self"],["metadata"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["metadatabuilder"]],["option",["ordering"]]]],[11,"lt","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"le","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"gt","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"ge","","",6,[[["self"],["metadatabuilder"]],["bool"]]],[11,"from_str","","",0,[[["str"]],["result",["level"]]]],[11,"from_str","","",1,[[["str"]],["result",["levelfilter"]]]],[11,"hash","","",0,N],[11,"hash","","",1,N],[11,"hash","","",5,N],[11,"hash","","",6,N],[11,"clone","","",0,[[["self"]],["level"]]],[11,"clone","","",1,[[["self"]],["levelfilter"]]],[11,"clone","","",3,[[["self"]],["record"]]],[11,"clone","","",5,[[["self"]],["metadata"]]]],"paths":[[4,"Level"],[4,"LevelFilter"],[8,"Log"],[3,"Record"],[3,"RecordBuilder"],[3,"Metadata"],[3,"MetadataBuilder"],[3,"SetLoggerError"],[3,"ParseLevelError"]]};
searchIndex["num_traits"]={"doc":"Numeric traits for generic mathematics","items":[[3,"ParseFloatError","num_traits","",N,N],[12,"kind","","",0,N],[4,"FloatErrorKind","","",N,N],[13,"Empty","","",1,N],[13,"Invalid","","",1,N],[5,"clamp","","A value bounded by a minimum and a maximum",N,[[["t"],["t"],["t"]],["t"]]],[0,"bounds","","",N,N],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",N,N],[10,"min_value","","returns the smallest finite number this type can represent",2,[[],["self"]]],[10,"max_value","","returns the largest finite number this type can represent",2,[[],["self"]]],[0,"cast","num_traits","",N,N],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",N,[[["t"]],["option"]]],[8,"ToPrimitive","","A generic trait for converting a value to a number.",N,N],[11,"to_isize","","Converts the value of `self` to an `isize`.",3,[[["self"]],["option",["isize"]]]],[11,"to_i8","","Converts the value of `self` to an `i8`.",3,[[["self"]],["option",["i8"]]]],[11,"to_i16","","Converts the value of `self` to an `i16`.",3,[[["self"]],["option",["i16"]]]],[11,"to_i32","","Converts the value of `self` to an `i32`.",3,[[["self"]],["option",["i32"]]]],[10,"to_i64","","Converts the value of `self` to an `i64`.",3,[[["self"]],["option",["i64"]]]],[11,"to_i128","","Converts the value of `self` to an `i128`.",3,[[["self"]],["option",["i128"]]]],[11,"to_usize","","Converts the value of `self` to a `usize`.",3,[[["self"]],["option",["usize"]]]],[11,"to_u8","","Converts the value of `self` to an `u8`.",3,[[["self"]],["option",["u8"]]]],[11,"to_u16","","Converts the value of `self` to an `u16`.",3,[[["self"]],["option",["u16"]]]],[11,"to_u32","","Converts the value of `self` to an `u32`.",3,[[["self"]],["option",["u32"]]]],[10,"to_u64","","Converts the value of `self` to an `u64`.",3,[[["self"]],["option",["u64"]]]],[11,"to_u128","","Converts the value of `self` to an `u128`.",3,[[["self"]],["option",["u128"]]]],[11,"to_f32","","Converts the value of `self` to an `f32`.",3,[[["self"]],["option",["f32"]]]],[11,"to_f64","","Converts the value of `self` to an `f64`.",3,[[["self"]],["option",["f64"]]]],[8,"FromPrimitive","","A generic trait for converting a number to a value.",N,N],[11,"from_isize","","Convert an `isize` to return an optional value of this…",4,[[["isize"]],["option"]]],[11,"from_i8","","Convert an `i8` to return an optional value of this type.…",4,[[["i8"]],["option"]]],[11,"from_i16","","Convert an `i16` to return an optional value of this type.…",4,[[["i16"]],["option"]]],[11,"from_i32","","Convert an `i32` to return an optional value of this type.…",4,[[["i32"]],["option"]]],[10,"from_i64","","Convert an `i64` to return an optional value of this type.…",4,[[["i64"]],["option"]]],[11,"from_i128","","Convert an `i128` to return an optional value of this…",4,[[["i128"]],["option"]]],[11,"from_usize","","Convert a `usize` to return an optional value of this…",4,[[["usize"]],["option"]]],[11,"from_u8","","Convert an `u8` to return an optional value of this type.…",4,[[["u8"]],["option"]]],[11,"from_u16","","Convert an `u16` to return an optional value of this type.…",4,[[["u16"]],["option"]]],[11,"from_u32","","Convert an `u32` to return an optional value of this type.…",4,[[["u32"]],["option"]]],[10,"from_u64","","Convert an `u64` to return an optional value of this type.…",4,[[["u64"]],["option"]]],[11,"from_u128","","Convert an `u128` to return an optional value of this…",4,[[["u128"]],["option"]]],[11,"from_f32","","Convert a `f32` to return an optional value of this type.…",4,[[["f32"]],["option"]]],[11,"from_f64","","Convert a `f64` to return an optional value of this type.…",4,[[["f64"]],["option"]]],[8,"NumCast","","An interface for casting between machine scalars.",N,N],[10,"from","","Creates a number from another value that can be converted…",5,[[["t"]],["option"]]],[8,"AsPrimitive","","A generic interface for casting between machine scalars…",N,N],[10,"as_","","Convert a value to another, using the `as` operator.",6,[[["self"]],["t"]]],[0,"float","num_traits","",N,N],[8,"FloatCore","num_traits::float","Generic trait for floating point numbers that works with…",N,N],[10,"infinity","","Returns positive infinity.",7,[[],["self"]]],[10,"neg_infinity","","Returns negative infinity.",7,[[],["self"]]],[10,"nan","","Returns NaN.",7,[[],["self"]]],[10,"neg_zero","","Returns `-0.0`.",7,[[],["self"]]],[10,"min_value","","Returns the smallest finite value that this type can…",7,[[],["self"]]],[10,"min_positive_value","","Returns the smallest positive, normalized value that this…",7,[[],["self"]]],[10,"epsilon","","Returns epsilon, a small positive value.",7,[[],["self"]]],[10,"max_value","","Returns the largest finite value that this type can…",7,[[],["self"]]],[11,"is_nan","","Returns `true` if the number is NaN.",7,[[["self"]],["bool"]]],[11,"is_infinite","","Returns `true` if the number is infinite.",7,[[["self"]],["bool"]]],[11,"is_finite","","Returns `true` if the number is neither infinite or NaN.",7,[[["self"]],["bool"]]],[11,"is_normal","","Returns `true` if the number is neither zero, infinite,…",7,[[["self"]],["bool"]]],[10,"classify","","Returns the floating point category of the number. If only…",7,[[["self"]],["fpcategory"]]],[11,"floor","","Returns the largest integer less than or equal to a number.",7,[[["self"]],["self"]]],[11,"ceil","","Returns the smallest integer greater than or equal to a…",7,[[["self"]],["self"]]],[11,"round","","Returns the nearest integer to a number. Round half-way…",7,[[["self"]],["self"]]],[11,"trunc","","Return the integer part of a number.",7,[[["self"]],["self"]]],[11,"fract","","Returns the fractional part of a number.",7,[[["self"]],["self"]]],[11,"abs","","Computes the absolute value of `self`. Returns…",7,[[["self"]],["self"]]],[11,"signum","","Returns a number that represents the sign of `self`.",7,[[["self"]],["self"]]],[11,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and…",7,[[["self"]],["bool"]]],[11,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and…",7,[[["self"]],["bool"]]],[11,"min","","Returns the minimum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"max","","Returns the maximum of the two numbers.",7,[[["self"],["self"]],["self"]]],[11,"recip","","Returns the reciprocal (multiplicative inverse) of the…",7,[[["self"]],["self"]]],[11,"powi","","Raise a number to an integer power.",7,[[["self"],["i32"]],["self"]]],[10,"to_degrees","","Converts to degrees, assuming the number is in radians.",7,[[["self"]],["self"]]],[10,"to_radians","","Converts to radians, assuming the number is in degrees.",7,[[["self"]],["self"]]],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as…",7,N],[8,"FloatConst","","",N,N],[10,"E","","Return Euler’s number.",8,[[],["self"]]],[10,"FRAC_1_PI","","Return `1.0 / π`.",8,[[],["self"]]],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",8,[[],["self"]]],[10,"FRAC_2_PI","","Return `2.0 / π`.",8,[[],["self"]]],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",8,[[],["self"]]],[10,"FRAC_PI_2","","Return `π / 2.0`.",8,[[],["self"]]],[10,"FRAC_PI_3","","Return `π / 3.0`.",8,[[],["self"]]],[10,"FRAC_PI_4","","Return `π / 4.0`.",8,[[],["self"]]],[10,"FRAC_PI_6","","Return `π / 6.0`.",8,[[],["self"]]],[10,"FRAC_PI_8","","Return `π / 8.0`.",8,[[],["self"]]],[10,"LN_10","","Return `ln(10.0)`.",8,[[],["self"]]],[10,"LN_2","","Return `ln(2.0)`.",8,[[],["self"]]],[10,"LOG10_E","","Return `log10(e)`.",8,[[],["self"]]],[10,"LOG2_E","","Return `log2(e)`.",8,[[],["self"]]],[10,"PI","","Return Archimedes’ constant.",8,[[],["self"]]],[10,"SQRT_2","","Return `sqrt(2.0)`.",8,[[],["self"]]],[0,"identities","num_traits","",N,N],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",N,[[],["t"]]],[5,"one","","Returns the multiplicative identity, `1`.",N,[[],["t"]]],[8,"Zero","","Defines an additive identity element for `Self`.",N,N],[10,"zero","","Returns the additive identity element of `Self`, `0`.",9,[[],["self"]]],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",9,[[["self"]],["bool"]]],[8,"One","","Defines a multiplicative identity element for `Self`.",N,N],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",10,[[],["self"]]],[11,"is_one","","Returns `true` if `self` is equal to the multiplicative…",10,[[["self"]],["bool"]]],[0,"int","num_traits","",N,N],[8,"PrimInt","num_traits::int","",N,N],[10,"count_ones","","Returns the number of ones in the binary representation of…",11,[[["self"]],["u32"]]],[10,"count_zeros","","Returns the number of zeros in the binary representation…",11,[[["self"]],["u32"]]],[10,"leading_zeros","","Returns the number of leading zeros in the binary…",11,[[["self"]],["u32"]]],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary…",11,[[["self"]],["u32"]]],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount,…",11,[[["self"],["u32"]],["self"]]],[10,"swap_bytes","","Reverses the byte order of the integer.",11,[[["self"]],["self"]]],[10,"from_be","","Convert an integer from big endian to the target's…",11,[[["self"]],["self"]]],[10,"from_le","","Convert an integer from little endian to the target's…",11,[[["self"]],["self"]]],[10,"to_be","","Convert `self` to big endian from the target's endianness.",11,[[["self"]],["self"]]],[10,"to_le","","Convert `self` to little endian from the target's…",11,[[["self"]],["self"]]],[10,"pow","","Raises self to the power of `exp`, using exponentiation by…",11,[[["self"],["u32"]],["self"]]],[0,"ops","num_traits","",N,N],[0,"checked","num_traits::ops","",N,N],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping…",N,N],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow…",12,[[["self"],["self"]],["option"]]],[8,"CheckedSub","","Performs subtraction that returns `None` instead of…",N,N],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If…",13,[[["self"],["self"]],["option"]]],[8,"CheckedMul","","Performs multiplication that returns `None` instead of…",N,N],[10,"checked_mul","","Multiplies two numbers, checking for underflow or…",14,[[["self"],["self"]],["option"]]],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking…",N,N],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and…",15,[[["self"],["self"]],["option"]]],[8,"CheckedRem","","Performs an integral remainder that returns `None` instead…",N,N],[10,"checked_rem","","Finds the remainder of dividing two numbers, checking for…",16,[[["self"],["self"]],["option"]]],[8,"CheckedNeg","","Performs negation that returns `None` if the result can't…",N,N],[10,"checked_neg","","Negates a number, returning `None` for results that can't…",17,[[["self"]],["option"]]],[8,"CheckedShl","","Performs a left shift that returns `None` on overflow.",N,N],[10,"checked_shl","","Shifts a number to the left, checking for overflow. If…",18,[[["self"],["u32"]],["option"]]],[8,"CheckedShr","","Performs a right shift that returns `None` on overflow.",N,N],[10,"checked_shr","","Shifts a number to the left, checking for overflow. If…",19,[[["self"],["u32"]],["option"]]],[0,"inv","num_traits::ops","",N,N],[8,"Inv","num_traits::ops::inv","Unary operator for retrieving the multiplicative inverse,…",N,N],[16,"Output","","The result after applying the operator.",20,N],[10,"inv","","Returns the multiplicative inverse of `self`.",20,N],[0,"mul_add","num_traits::ops","",N,N],[8,"MulAdd","num_traits::ops::mul_add","Fused multiply-add. Computes `(self * a) + b` with only…",N,N],[16,"Output","","The resulting type after applying the fused multiply-add.",21,N],[10,"mul_add","","Performs the fused multiply-add operation.",21,N],[8,"MulAddAssign","","The fused multiply-add assignment operation.",N,N],[10,"mul_add_assign","","Performs the fused multiply-add operation.",22,[[["self"],["a"],["b"]]]],[0,"saturating","num_traits::ops","",N,N],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",N,N],[10,"saturating_add","","Saturating addition operator. Returns a+b, saturating at…",23,[[["self"],["self"]],["self"]]],[10,"saturating_sub","","Saturating subtraction operator. Returns a-b, saturating…",23,[[["self"],["self"]],["self"]]],[0,"wrapping","num_traits::ops","",N,N],[8,"WrappingAdd","num_traits::ops::wrapping","Performs addition that wraps around on overflow.",N,N],[10,"wrapping_add","","Wrapping (modular) addition. Computes `self + other`,…",24,[[["self"],["self"]],["self"]]],[8,"WrappingSub","","Performs subtraction that wraps around on overflow.",N,N],[10,"wrapping_sub","","Wrapping (modular) subtraction. Computes `self - other`,…",25,[[["self"],["self"]],["self"]]],[8,"WrappingMul","","Performs multiplication that wraps around on overflow.",N,N],[10,"wrapping_mul","","Wrapping (modular) multiplication. Computes `self *…",26,[[["self"],["self"]],["self"]]],[8,"WrappingShl","","Performs a left shift that does not panic.",N,N],[10,"wrapping_shl","","Panic-free bitwise shift-left; yields `self << mask(rhs)`,…",27,[[["self"],["u32"]],["self"]]],[8,"WrappingShr","","Performs a right shift that does not panic.",N,N],[10,"wrapping_shr","","Panic-free bitwise shift-right; yields `self >>…",28,[[["self"],["u32"]],["self"]]],[0,"pow","num_traits","",N,N],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation…",N,[[["t"],["usize"]],["t"]]],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an…",N,[[["t"],["usize"]],["option"]]],[8,"Pow","","Binary operator for raising a value to a power.",N,N],[16,"Output","","The result after applying the operator.",29,N],[10,"pow","","Returns `self` to the power `rhs`.",29,N],[0,"sign","num_traits","",N,N],[5,"abs","num_traits::sign","Computes the absolute value.",N,[[["t"]],["t"]]],[5,"abs_sub","","The positive difference of two numbers.",N,[[["t"],["t"]],["t"]]],[5,"signum","","Returns the sign of the number.",N,[[["t"]],["t"]]],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can…",N,N],[10,"abs","","Computes the absolute value.",30,[[["self"]],["self"]]],[10,"abs_sub","","The positive difference of two numbers.",30,[[["self"],["self"]],["self"]]],[10,"signum","","Returns the sign of the number.",30,[[["self"]],["self"]]],[10,"is_positive","","Returns true if the number is positive and false if the…",30,[[["self"]],["bool"]]],[10,"is_negative","","Returns true if the number is negative and false if the…",30,[[["self"]],["bool"]]],[8,"Unsigned","","A trait for values which cannot be negative",N,N],[8,"Num","num_traits","The base trait for numeric types, covering `0` and `1`…",N,N],[16,"FromStrRadixErr","","",31,N],[10,"from_str_radix","","Convert from a string and radix <= 36.",31,[[["str"],["u32"]],["result"]]],[8,"NumOps","","The trait for types implementing basic numeric operations",N,N],[8,"NumRef","","The trait for `Num` types which also implement numeric…",N,N],[8,"RefNum","","The trait for references which implement numeric…",N,N],[8,"NumAssignOps","","The trait for types implementing numeric assignment…",N,N],[8,"NumAssign","","The trait for `Num` types which also implement assignment…",N,N],[8,"NumAssignRef","","The trait for `NumAssign` types which also implement…",N,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Bounded"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"AsPrimitive"],[8,"FloatCore"],[8,"FloatConst"],[8,"Zero"],[8,"One"],[8,"PrimInt"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"CheckedRem"],[8,"CheckedNeg"],[8,"CheckedShl"],[8,"CheckedShr"],[8,"Inv"],[8,"MulAdd"],[8,"MulAddAssign"],[8,"Saturating"],[8,"WrappingAdd"],[8,"WrappingSub"],[8,"WrappingMul"],[8,"WrappingShl"],[8,"WrappingShr"],[8,"Pow"],[8,"Signed"],[8,"Num"]]};
searchIndex["spin"]={"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",N,N],[3,"MutexGuard","","A guard to which the protected data can be accessed",N,N],[3,"RwLock","","A reader-writer lock",N,N],[3,"RwLockReadGuard","","A guard to which the protected data can be read",N,N],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",N,N],[3,"Once","","A synchronization primitive which can be used to run a…",N,N],[11,"new","","Creates a new spinlock wrapping the supplied data.",0,[[["t"]],["mutex"]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",0,[[["self"]],["t"]]],[11,"lock","","Locks the spinlock and returns a guard.",0,[[["self"]],["mutexguard"]]],[11,"force_unlock","","Force unlock the spinlock.",0,[[["self"]]]],[11,"try_lock","","Tries to lock the mutex. If it is already locked, it will…",0,[[["self"]],["option",["mutexguard"]]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",1,[[["t"]],["rwlock"]]],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",1,[[["self"]],["t"]]],[11,"read","","Locks this rwlock with shared read access, blocking the…",1,[[["self"]],["rwlockreadguard"]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",1,[[["self"]],["option",["rwlockreadguard"]]]],[11,"force_read_decrement","","Force decrement the reader count.",1,[[["self"]]]],[11,"force_write_unlock","","Force unlock exclusive write access.",1,[[["self"]]]],[11,"write","","Lock this rwlock with exclusive write access, blocking the…",1,[[["self"]],["rwlockwriteguard"]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",1,[[["self"]],["option",["rwlockwriteguard"]]]],[18,"INIT","","Initialization constant of `Once`.",2,N],[11,"new","","Creates a new `Once` value.",2,[[],["once"]]],[11,"call_once","","Performs an initialization routine once and only once. The…",2,[[["self"],["f"]],["t"]]],[11,"try","","Returns a pointer iff the `Once` was previously initialized",2,[[["self"]],["option"]]],[11,"wait","","Like try, but will spin if the `Once` is in the process of…",2,[[["self"]],["option"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"deref","","",3,[[["self"]],["t"]]],[11,"deref","","",4,[[["self"]],["t"]]],[11,"deref","","",5,[[["self"]],["t"]]],[11,"deref_mut","","",3,[[["self"]],["t"]]],[11,"deref_mut","","",5,[[["self"]],["t"]]],[11,"drop","","The dropping of the MutexGuard will release the lock it…",3,[[["self"]]]],[11,"drop","","",4,[[["self"]]]],[11,"drop","","",5,[[["self"]]]],[11,"default","","",0,[[],["mutex"]]],[11,"default","","",1,[[],["rwlock"]]]],"paths":[[3,"Mutex"],[3,"RwLock"],[3,"Once"],[3,"MutexGuard"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"]]};
searchIndex["x86_64"]={"doc":"","items":[[0,"boot","x86_64","TODO",N,N],[3,"MemoryEntry","x86_64::boot","TODO",N,N],[12,"area","","",0,N],[12,"memory_type","","",0,N],[3,"BootInfo","","This structure is placed in memory by the bootloader and a…",N,N],[12,"magic","","This should be set to `BOOT_INFO_MAGIC` by the bootloader.",1,N],[12,"memory_map","","",1,N],[12,"num_memory_map_entries","","",1,N],[4,"MemoryType","","",N,N],[13,"UefiServices","","Memory used by the UEFI services. Cannot be used by the OS.",2,N],[13,"Conventional","","Conventional memory that can freely be used by the OS,",2,N],[13,"AcpiReclaimable","","Memory that contains ACPI tables. After the OS has parsed…",2,N],[13,"SleepPreserve","","This marks memory that the OS should preserve in the…",2,N],[13,"NonVolatileSleepPreserve","","This marks memory that the OS should preserve in the…",2,N],[13,"KernelImage","","Memory the bootloader has mapped the kernel image into.…",2,N],[13,"KernelPageTables","","Memory the bootloader has used for the page tables…",2,N],[13,"KernelHeap","","Memory the bootloader has mapped for use as the kernel…",2,N],[13,"BootInfo","","Memory used for storing the `BootInfo` by the bootloader.…",2,N],[17,"BOOT_INFO_MAGIC","","",N,N],[17,"MEMORY_MAP_NUM_ENTRIES","","",N,N],[11,"memory_entries","","",1,N],[0,"hw","x86_64","",N,N],[0,"port","x86_64::hw","",N,N],[3,"Port","x86_64::hw::port","Represents an IO port that can be read and written to…",N,N],[8,"PortSize","","Implemented by the types used to represent 8-bit, 16-bit,…",N,N],[10,"port_read","","",3,[[["u16"]],["self"]]],[10,"port_write","","",3,[[["u16"],["self"]]]],[11,"new","","Create a new `Port` at the specified I/O address. Unsafe…",4,[[["u16"]],["port"]]],[11,"read","","",4,[[["self"]],["t"]]],[11,"write","","",4,[[["self"],["t"]]]],[0,"registers","x86_64::hw","",N,N],[17,"EFER","x86_64::hw::registers","",N,N],[0,"serial","x86_64::hw","",N,N],[3,"SerialPort","x86_64::hw::serial","",N,N],[17,"COM1","","",N,N],[11,"new","","",5,[[["u16"]],["serialport"]]],[11,"initialise","","",5,[[["self"]]]],[11,"read","","",5,[[["self"]],["u8"]]],[11,"write","","",5,[[["self"],["u8"]]]],[0,"tlb","x86_64::hw","",N,N],[5,"invalidate_page","x86_64::hw::tlb","",N,[[["virtualaddress"]]]],[5,"flush","","",N,[[]]],[0,"memory","x86_64","",N,N],[3,"PhysicalAddress","x86_64::memory","Represents an address in the physical memory space. A…",N,N],[3,"VirtualAddress","","Represents a canonical virtual address. To be canonical,…",N,N],[0,"kernel_map","","These constants define the layout of the memory map when…",N,N],[17,"RECURSIVE_ENTRY","x86_64::memory::kernel_map","We use the 510th entry of the PML4 (P4) to access the page…",N,N],[17,"P4_TABLE_ADDRESS","","This address can be used to access the currently mapped P4…",N,N],[17,"KERNEL_BASE","","This is the base of the kernel address space. It starts at…",N,N],[17,"HEAP_START","","This is the address of the start of the kernel heap. The…",N,N],[17,"HEAP_END","","",N,N],[17,"BOOT_INFO","","",N,N],[17,"LOCAL_APIC_CONFIG_PAGE","","",N,N],[0,"paging","x86_64::memory","",N,N],[8,"Deref","x86_64::memory::paging","Used for immutable dereferencing operations, like `*v`.",N,N],[16,"Target","","The resulting type after dereferencing.",6,N],[10,"deref","","Dereferences the value.",6,N],[8,"DerefMut","","Used for mutable dereferencing operations, like in `*v =…",N,N],[10,"deref_mut","","Mutably dereferences the value.",7,N],[3,"InactivePageTable","","Represents a set of page tables that are not currently…",N,N],[3,"ActivePageTable","","Represents the set of page tables that are currently being…",N,N],[0,"entry","","",N,N],[3,"Entry","x86_64::memory::paging::entry","",N,N],[3,"EntryFlags","","",N,N],[18,"PRESENT","","",8,N],[18,"WRITABLE","","",8,N],[18,"USER_ACCESSIBLE","","",8,N],[18,"WRITE_THROUGH","","",8,N],[18,"NO_CACHE","","",8,N],[18,"ACCESSED","","",8,N],[18,"DIRTY","","",8,N],[18,"HUGE_PAGE","","",8,N],[18,"GLOBAL","","",8,N],[18,"NO_EXECUTE","","",8,N],[11,"empty","","Returns an empty set of flags.",8,[[],["entryflags"]]],[11,"all","","Returns the set containing all flags.",8,[[],["entryflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",8,[[["self"]],["u64"]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",8,[[["u64"]],["option",["entryflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",8,[[["u64"]],["entryflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",8,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",8,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",8,[[["self"],["entryflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",8,[[["self"],["entryflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",8,[[["self"],["entryflags"]]]],[11,"remove","","Removes the specified flags in-place.",8,[[["self"],["entryflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",8,[[["self"],["entryflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the…",8,[[["self"],["entryflags"],["bool"]]]],[11,"is_compatible","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"is_unused","","",9,[[["self"]],["bool"]]],[11,"set_unused","","",9,[[["self"]]]],[11,"flags","","",9,[[["self"]],["entryflags"]]],[11,"pointed_frame","","",9,[[["self"]],["option",["frame"]]]],[11,"set","","",9,[[["self"],["frame"],["entryflags"]]]],[0,"frame","x86_64::memory::paging","",N,N],[3,"Frame","x86_64::memory::paging::frame","",N,N],[11,"contains","","",10,[[["physicaladdress"]],["frame"]]],[11,"start_address","","",10,[[["self"]],["physicaladdress"]]],[0,"frame_allocator","x86_64::memory::paging","",N,N],[8,"FrameAllocator","x86_64::memory::paging::frame_allocator","`FrameAllocator` represents the `x86_64` crate's interface…",N,N],[11,"allocate","","Allocate a `Frame`.",11,[[["self"]],["frame"]]],[10,"allocate_n","","Allocate `n` contiguous `Frame`s.",11,[[["self"],["usize"]],["range",["frame"]]]],[10,"free_n","","Free `n` frames that were previously allocated by this…",11,[[["self"],["frame"],["usize"]]]],[0,"mapper","x86_64::memory::paging","",N,N],[3,"Mapper","x86_64::memory::paging::mapper","A `Mapper` allows you to change the virtual to physical…",N,N],[11,"translate","","Get the `PhysicalAddress` a given `VirtualAddress` is…",12,[[["self"],["virtualaddress"]],["option",["physicaladdress"]]]],[11,"translate_page","","Get the physical `Frame` that a given virtual `Page` is…",12,[[["self"],["page"]],["option",["frame"]]]],[11,"map","","Map the given `Page` somewhere in physical memory.…",12,[[["self"],["page"],["entryflags"],["a"]]]],[11,"map_to","","",12,[[["self"],["page"],["frame"],["entryflags"],["a"]]]],[11,"unmap","","",12,[[["self"],["page"],["a"]]]],[0,"page","x86_64::memory::paging","",N,N],[3,"Page","x86_64::memory::paging::page","",N,N],[11,"contains","","Get the page that contains the given virtual address.",13,[[["virtualaddress"]],["page"]]],[11,"start_address","","",13,[[["self"]],["virtualaddress"]]],[11,"p4_index","","",13,[[["self"]],["u16"]]],[11,"p3_index","","",13,[[["self"]],["u16"]]],[11,"p2_index","","",13,[[["self"]],["u16"]]],[11,"p1_index","","",13,[[["self"]],["u16"]]],[0,"table","x86_64::memory::paging","This module contains types for representing raw page…",N,N],[3,"Table","x86_64::memory::paging::table","Represents a page table, with 512 entries which are either…",N,N],[4,"Level4","","",N,N],[4,"Level3","","",N,N],[4,"Level2","","",N,N],[4,"Level1","","",N,N],[4,"IdentityMapping","","This is a marker type that specifies that we are in an…",N,N],[4,"RecursiveMapping","","This is a marker type that specifies that we are in an…",N,N],[8,"TableLevel","","",N,N],[8,"HierarchicalLevel","","Tables of levels that implement `HierarchicalLevel` are…",N,N],[16,"NextLevel","","",14,N],[8,"TableMapping","","This trait specifies how we should access and modify a set…",N,N],[10,"next_table_address","","",15,[[["table"],["u16"]],["option",["virtualaddress"]]]],[11,"zero","","",16,[[["self"]]]],[11,"next_table","","",16,[[["self"],["u16"]],["option",["table"]]]],[11,"next_table_mut","","",16,[[["self"],["u16"]],["option",["table"]]]],[11,"next_table_create","","",16,[[["self"],["u16"],["bool"],["a"]],["table"]]],[17,"FRAME_SIZE","x86_64::memory::paging","",N,N],[17,"PAGE_SIZE","","",N,N],[11,"mapper","","",17,[[["self"]],["mapper",["identitymapping"]]]],[11,"new","","Create a new set of page-tables. `frame` must be an…",17,[[["frame"]],["inactivepagetable"]]],[11,"switch_to","","Switch to this set of page tables. This returns a tuple…",17,N],[11,"switch_to","","Switch to this set of page tables. This returns a tuple…",17,N],[11,"new","","Create an `ActivePageTable` to represent an active set of…",18,[[["physicaladdress"]],["activepagetable",["identitymapping"]]]],[11,"new","","Create an `ActivePageTable` to represent the…",18,[[],["activepagetable",["recursivemapping"]]]],[11,"with","","Alter the mappings of a `InactivePageTable` by temporarily…",18,[[["self"],["inactivepagetable"],["a"],["f"]]]],[11,"new","x86_64::memory","",19,[[["usize"]],["option",["physicaladdress"]]]],[11,"new_unchecked","","",19,[[["usize"]],["physicaladdress"]]],[11,"offset_into_frame","","",19,[[["self"]],["usize"]]],[11,"is_frame_aligned","","",19,[[["self"]],["bool"]]],[11,"new","","Create a new `VirtualAddress` from the given address. If…",20,[[["usize"]],["option",["virtualaddress"]]]],[11,"new_unchecked","","Create a new `VirtualAddress` from the given address,…",20,[[["usize"]],["virtualaddress"]]],[11,"new_canonicalise","","Create a new `VirtualAddress` from the given address,…",20,[[["usize"]],["virtualaddress"]]],[11,"from_page_table_offsets","","",20,[[["u16"],["u16"],["u16"],["u16"],["usize"]],["virtualaddress"]]],[11,"ptr","","",20,N],[11,"mut_ptr","","",20,N],[11,"offset","","",20,[[["self"],["i64"]],["virtualaddress"]]],[11,"is_page_aligned","","",20,[[["self"]],["bool"]]],[11,"is_aligned_to","","",20,[[["self"],["usize"]],["bool"]]],[11,"offset_into_page","","",20,[[["self"]],["usize"]]],[11,"align_down","","Get the greatest address `x` with the given alignment such…",20,[[["self"],["usize"]],["virtualaddress"]]],[11,"align_up","","Get the smallest address `x` with the given alignment such…",20,[[["self"],["usize"]],["virtualaddress"]]],[11,"canonicalise","","Addresses are always expected by the CPU to be canonical…",20,[[["self"]],["virtualaddress"]]],[14,"read_control_reg","x86_64","Read a control register. The name of the control register…",N,N],[14,"write_control_reg","","Write to a control register. Calls to this macro will need…",N,N],[14,"read_msr","","Read from a model-specific register.",N,N],[14,"write_msr","","Write to a model-specific register. This is unsafe,…",N,N],[11,"from","x86_64::boot","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","x86_64::hw::port","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","x86_64::hw::serial","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","x86_64::memory","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging::entry","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging::frame","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging::mapper","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging::page","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","x86_64::memory::paging::table","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"next_table_address","","",25,[[["table"],["u16"]],["option",["virtualaddress"]]]],[11,"next_table_address","","",26,[[["table"],["u16"]],["option",["virtualaddress"]]]],[11,"from","x86_64::memory","",20,N],[11,"from","","",20,N],[11,"fmt","x86_64::boot","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory::paging::entry","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory::paging::frame","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory::paging::page","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"eq","x86_64::boot","",2,[[["self"],["memorytype"]],["bool"]]],[11,"eq","x86_64::memory::paging::entry","",8,[[["self"],["entryflags"]],["bool"]]],[11,"ne","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"eq","x86_64::memory::paging::frame","",10,[[["self"],["frame"]],["bool"]]],[11,"ne","","",10,[[["self"],["frame"]],["bool"]]],[11,"eq","x86_64::memory::paging::page","",13,[[["self"],["page"]],["bool"]]],[11,"ne","","",13,[[["self"],["page"]],["bool"]]],[11,"eq","x86_64::memory","",19,[[["self"],["physicaladdress"]],["bool"]]],[11,"eq","","",20,[[["self"],["virtualaddress"]],["bool"]]],[11,"cmp","x86_64::memory::paging::entry","",8,[[["self"],["entryflags"]],["ordering"]]],[11,"cmp","x86_64::memory::paging::frame","",10,[[["self"],["frame"]],["ordering"]]],[11,"cmp","x86_64::memory::paging::page","",13,[[["self"],["page"]],["ordering"]]],[11,"cmp","x86_64::memory","",19,[[["self"],["physicaladdress"]],["ordering"]]],[11,"cmp","","",20,[[["self"],["virtualaddress"]],["ordering"]]],[11,"partial_cmp","x86_64::memory::paging::entry","",8,[[["self"],["entryflags"]],["option",["ordering"]]]],[11,"lt","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"le","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"gt","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"ge","","",8,[[["self"],["entryflags"]],["bool"]]],[11,"partial_cmp","x86_64::memory::paging::frame","",10,[[["self"],["frame"]],["option",["ordering"]]]],[11,"lt","","",10,[[["self"],["frame"]],["bool"]]],[11,"le","","",10,[[["self"],["frame"]],["bool"]]],[11,"gt","","",10,[[["self"],["frame"]],["bool"]]],[11,"ge","","",10,[[["self"],["frame"]],["bool"]]],[11,"partial_cmp","x86_64::memory::paging::page","",13,[[["self"],["page"]],["option",["ordering"]]]],[11,"lt","","",13,[[["self"],["page"]],["bool"]]],[11,"le","","",13,[[["self"],["page"]],["bool"]]],[11,"gt","","",13,[[["self"],["page"]],["bool"]]],[11,"ge","","",13,[[["self"],["page"]],["bool"]]],[11,"partial_cmp","x86_64::memory","",19,[[["self"],["physicaladdress"]],["option",["ordering"]]]],[11,"partial_cmp","","",20,[[["self"],["virtualaddress"]],["option",["ordering"]]]],[11,"add","x86_64::memory::paging::frame","",10,N],[11,"add","x86_64::memory::paging::page","",13,N],[11,"add","x86_64::memory","",19,N],[11,"add","","",20,N],[11,"sub","x86_64::memory::paging::entry","Returns the set difference of the two sets of flags.",8,[[["self"],["entryflags"]],["entryflags"]]],[11,"sub","x86_64::memory","",19,N],[11,"sub","","",20,N],[11,"add_assign","x86_64::memory::paging::frame","",10,[[["self"],["usize"]]]],[11,"add_assign","x86_64::memory::paging::page","",13,[[["self"],["usize"]]]],[11,"sub_assign","x86_64::memory::paging::entry","Disables all flags enabled in the set.",8,[[["self"],["entryflags"]]]],[11,"not","","Returns the complement of this set of flags.",8,[[["self"]],["entryflags"]]],[11,"bitand","","Returns the intersection between the two sets of flags.",8,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitor","","Returns the union of the two sets of flags.",8,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",8,[[["self"],["entryflags"]],["entryflags"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",8,[[["self"],["entryflags"]]]],[11,"bitor_assign","","Adds the set of flags.",8,[[["self"],["entryflags"]]]],[11,"bitxor_assign","","Toggles the set of flags.",8,[[["self"],["entryflags"]]]],[11,"deref","x86_64::memory::paging","",18,N],[11,"deref_mut","","",18,N],[11,"index","x86_64::memory::paging::table","",16,[[["self"],["u16"]],["entry"]]],[11,"index_mut","","",16,[[["self"],["u16"]],["entry"]]],[11,"hash","x86_64::memory::paging::entry","",8,N],[11,"from_iter","","",8,[[["t"]],["entryflags"]]],[11,"extend","","",8,[[["self"],["t"]]]],[11,"steps_between","x86_64::memory::paging::frame","",10,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",10,[[["self"]],["self"]]],[11,"replace_zero","","",10,[[["self"]],["self"]]],[11,"add_one","","",10,[[["self"]],["self"]]],[11,"sub_one","","",10,[[["self"]],["self"]]],[11,"add_usize","","",10,[[["self"],["usize"]],["option"]]],[11,"steps_between","x86_64::memory::paging::page","",13,[[["self"],["self"]],["option",["usize"]]]],[11,"replace_one","","",13,[[["self"]],["self"]]],[11,"replace_zero","","",13,[[["self"]],["self"]]],[11,"add_one","","",13,[[["self"]],["self"]]],[11,"sub_one","","",13,[[["self"]],["self"]]],[11,"add_usize","","",13,[[["self"],["usize"]],["option"]]],[11,"write_str","x86_64::hw::serial","",5,[[["self"],["str"]],["result"]]],[11,"fmt","x86_64::memory::paging::entry","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory::paging::entry","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","x86_64::memory","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"clone","x86_64::memory::paging::entry","",8,[[["self"]],["entryflags"]]],[11,"clone","x86_64::memory::paging::frame","",10,[[["self"]],["frame"]]],[11,"clone","x86_64::memory::paging::page","",13,[[["self"]],["page"]]],[11,"clone","x86_64::memory","",19,[[["self"]],["physicaladdress"]]],[11,"clone","","",20,[[["self"]],["virtualaddress"]]],[11,"default","x86_64::memory::paging::entry","",8,[[],["entryflags"]]],[11,"default","x86_64::memory","",19,[[],["physicaladdress"]]],[11,"default","","",20,[[],["virtualaddress"]]]],"paths":[[3,"MemoryEntry"],[3,"BootInfo"],[4,"MemoryType"],[8,"PortSize"],[3,"Port"],[3,"SerialPort"],[8,"Deref"],[8,"DerefMut"],[3,"EntryFlags"],[3,"Entry"],[3,"Frame"],[8,"FrameAllocator"],[3,"Mapper"],[3,"Page"],[8,"HierarchicalLevel"],[8,"TableMapping"],[3,"Table"],[3,"InactivePageTable"],[3,"ActivePageTable"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[4,"Level4"],[4,"Level3"],[4,"Level2"],[4,"Level1"],[4,"IdentityMapping"],[4,"RecursiveMapping"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);
